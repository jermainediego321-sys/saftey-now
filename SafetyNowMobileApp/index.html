<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Loadingâ€¦</title>

  <style>
    body {
      margin: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }

    #orbWrapper {
      width: 200px;
      height: 200px;
    }

    @media (max-width: 480px) {
      #orbWrapper { width: 140px; height: 140px; }
    }
    @media (min-width: 900px) {
      #orbWrapper { width: 260px; height: 260px; }
    }
  </style>
</head>
<body>

<div id="orbWrapper">
  <canvas id="orb3d"></canvas>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

  const wrap = document.getElementById("orbWrapper");
  const canvas = document.getElementById("orb3d");

  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 20);
  camera.position.set(0, 0, 4);

  /* ---------------------------
     LIGHTING
  ----------------------------*/
  scene.add(new THREE.AmbientLight(0x4fa9ff, 0.4));
  const rim = new THREE.DirectionalLight(0xffffff, 1.7);
  rim.position.set(2, 2, 4);
  scene.add(rim);

  /* ---------------------------
     MAIN BIG SASOL ORB
  ----------------------------*/
  const mainOrb = new THREE.Mesh(
    new THREE.SphereGeometry(1, 64, 64),
    new THREE.MeshPhysicalMaterial({
      color: 0x1B4D8C,
      roughness: 0.15,
      metalness: 0.2,
      transmission: 0.92,
      thickness: 1.0,
      clearcoat: 1.0,
      clearcoatRoughness: 0.05,
      emissive: new THREE.Color(0x4fa9ff),
      emissiveIntensity: 0.25
    })
  );
  scene.add(mainOrb);

  /* ---------------------------
     MINI BALLS AROUND ORB
  ----------------------------*/
  const miniBalls = [];
  const miniGeom = new THREE.SphereGeometry(0.25, 32, 32);
  const miniMat = new THREE.MeshPhysicalMaterial({
    color: 0x58a6ff,
    roughness: 0.2,
    metalness: 0.1,
    emissive: 0x6bbcff,
    emissiveIntensity: 0.6
  });

  for (let i = 0; i < 8; i++) {
    let b = new THREE.Mesh(miniGeom, miniMat);
    b.position.set(
      Math.cos((i / 8) * Math.PI * 2) * 1.8,
      Math.sin((i / 8) * Math.PI * 2) * 1.2,
      0
    );
    miniBalls.push(b);
    scene.add(b);
  }

  /* ---------------------------
     PARTICLE GAS BURST SYSTEM
  ----------------------------*/
  const particleCount = 160;
  let particles = new THREE.BufferGeometry();
  let positions = new Float32Array(particleCount * 3);

  for (let i = 0; i < particleCount; i++) {
    positions[i * 3] = 0;
    positions[i * 3 + 1] = 0;
    positions[i * 3 + 2] = 0;
  }

  particles.setAttribute("position", new THREE.BufferAttribute(positions, 3));

  const particleMaterial = new THREE.PointsMaterial({
    color: 0x8ccfff,
    size: 0.08,
    transparent: true,
    opacity: 0.9
  });

  const particleMesh = new THREE.Points(particles, particleMaterial);
  scene.add(particleMesh);

  let burstSpeed = [];
  function triggerBurst() {
    for (let i = 0; i < particleCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const upDown = (Math.random() - 0.5) * 2;
      burstSpeed[i] = new THREE.Vector3(
        Math.cos(angle) * (0.02 + Math.random() * 0.05),
        upDown * 0.03,
        Math.sin(angle) * (0.02 + Math.random() * 0.05)
      );
    }
  }

  triggerBurst(); // Burst immediately on load

  /* ---------------------------
     ANIMATION LOOP
  ----------------------------*/
  function animate() {
    // Rotate big orb
    mainOrb.rotation.y += 0.005;

    // Rotate mini-balls
    miniBalls.forEach((b, i) => {
      let t = performance.now() * 0.0006 + i;
      b.position.x = Math.cos(t) * 1.8;
      b.position.y = Math.sin(t * 1.3) * 1.2;
    });

    // Update particle burst
    let pos = particles.attributes.position.array;
    for (let i = 0; i < particleCount; i++) {
      pos[i * 3] += burstSpeed[i].x;
      pos[i * 3 + 1] += burstSpeed[i].y;
      pos[i * 3 + 2] += burstSpeed[i].z;
    }
    particles.attributes.position.needsUpdate = true;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();

  /* ---------------------------
     RESPONSIVE SIZE
  ----------------------------*/
  function resize() {
    const w = wrap.clientWidth;
    const h = wrap.clientHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  resize();
  new ResizeObserver(resize).observe(wrap);

  /* ---------------------------
     REDIRECT (7 SECONDS)
  ----------------------------*/
  setTimeout(() => {
    window.location.href = "login.html";
  }, 7000);
</script>

</body>
</html>
